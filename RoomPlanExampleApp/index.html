<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RoomPlan Data Extractor</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üìê</text></svg>">
  <style>
    :root {
      --primary-color: #007aff;
      --secondary-color: #5ac8fa;
      --success-color: #34c759;
      --warning-color: #ff9500;
      --error-color: #ff3b30;
      --background-color: #f5f5f7;
      --card-color: #ffffff;
      --text-color: #1d1d1f;
      --text-secondary: #86868b;
      --border-radius: 10px;
      --shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
      --transition: all 0.3s ease;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      background-color: var(--background-color);
      color: var(--text-color);
      line-height: 1.6;
      padding: 0;
      margin: 0;
    }

    .container {
      max-width: 1000px;
      margin: 0 auto;
      padding: 20px;
    }

    header {
      text-align: center;
      margin-bottom: 30px;
      padding: 20px 0;
    }

    h1 {
      font-size: 32px;
      font-weight: 600;
      margin-bottom: 10px;
      background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .subtitle {
      color: var(--text-secondary);
      font-size: 16px;
      max-width: 600px;
      margin: 0 auto;
    }

    .card {
      background-color: var(--card-color);
      border-radius: var(--border-radius);
      padding: 25px;
      margin-bottom: 25px;
      box-shadow: var(--shadow);
      transition: var(--transition);
    }

    .card:hover {
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.12);
    }

    .card-title {
      display: flex;
      align-items: center;
      margin-bottom: 15px;
      font-size: 18px;
      font-weight: 600;
      color: var(--primary-color);
    }

    .card-title i {
      margin-right: 10px;
    }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 10px 20px;
      background-color: var(--primary-color);
      color: white;
      border: none;
      border-radius: var(--border-radius);
      cursor: pointer;
      font-size: 16px;
      font-weight: 500;
      transition: var(--transition);
      margin-right: 10px;
      margin-bottom: 10px;
    }

    .btn:hover {
      background-color: #0062cc;
      transform: translateY(-2px);
    }

    .btn:active {
      transform: translateY(0);
    }

    .btn i {
      margin-right: 8px;
    }

    .btn.disabled {
      background-color: #d2d2d7;
      cursor: not-allowed;
    }

    .btn-secondary {
      background-color: transparent;
      color: var(--primary-color);
      border: 1px solid var(--primary-color);
    }

    .btn-secondary:hover {
      background-color: rgba(0, 122, 255, 0.1);
    }

    .alert {
      padding: 15px;
      border-radius: var(--border-radius);
      margin-bottom: 20px;
      display: flex;
      align-items: center;
    }

    .alert i {
      font-size: 24px;
      margin-right: 15px;
    }

    .alert-error {
      background-color: rgba(255, 59, 48, 0.1);
      border-left: 4px solid var(--error-color);
      color: var(--error-color);
    }

    .alert-success {
      background-color: rgba(52, 199, 89, 0.1);
      border-left: 4px solid var(--success-color);
      color: var(--success-color);
    }

    .result-section {
      display: none;
    }

    .result-card {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin-bottom: 20px;
    }

    .metric-box {
      background-color: rgba(0, 122, 255, 0.08);
      border-radius: var(--border-radius);
      padding: 15px;
      text-align: center;
    }

    .metric-value {
      font-size: 24px;
      font-weight: 600;
      margin: 10px 0;
      color: var(--primary-color);
    }

    .metric-label {
      font-size: 14px;
      color: var(--text-secondary);
    }

    .metric-unit {
      font-size: 14px;
      color: var(--text-secondary);
    }

    .walls-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
    }

    .walls-table th {
      background-color: rgba(0, 122, 255, 0.08);
      padding: 10px;
      text-align: left;
      font-weight: 500;
    }

    .walls-table td {
      padding: 10px;
      border-bottom: 1px solid #f2f2f2;
    }

    .measurements-toggle {
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 20px;
    }

    .toggle-label {
      margin: 0 10px;
    }

    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 60px;
      height: 30px;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 34px;
    }

    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 22px;
      width: 22px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }

    input:checked + .toggle-slider {
      background-color: var(--primary-color);
    }

    input:checked + .toggle-slider:before {
      transform: translateX(30px);
    }

    .current-unit {
      font-weight: 600;
    }

    .canvas-container {
      width: 100%;
      height: 400px;
      background-color: #f8f8f8;
      border-radius: var(--border-radius);
      margin-top: 20px;
      overflow: hidden;
      position: relative;
    }

    #roomCanvas {
      width: 100%;
      height: 100%;
    }

    .objects-list {
      margin-top: 20px;
    }

    .object-item {
      display: flex;
      justify-content: space-between;
      padding: 10px;
      border-bottom: 1px solid #f2f2f2;
    }

    .object-name {
      display: flex;
      align-items: center;
    }

    .object-icon {
      margin-right: 10px;
      color: var(--primary-color);
    }

    .features-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }

    .feature-card {
      background-color: #f8f8f8;
      border-radius: var(--border-radius);
      padding: 20px;
      text-align: center;
    }

    .feature-icon {
      font-size: 30px;
      color: var(--primary-color);
      margin-bottom: 15px;
    }

    .file-info {
      margin-top: 10px;
      font-size: 14px;
      color: var(--text-secondary);
    }

    footer {
      text-align: center;
      margin-top: 40px;
      padding: 20px 0;
      color: var(--text-secondary);
      font-size: 14px;
    }

    @media (max-width: 768px) {
      .container {
        padding: 15px;
      }
      
      .card {
        padding: 20px;
      }
      
      .result-card {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>RoomPlan Data Extractor</h1>
      <p class="subtitle">Extract, visualize, and analyze room dimensions from Apple RoomPlan JSON files</p>
    </header>

    <div id="alertContainer"></div>

    <div id="resultSection" class="result-section card">
      <h2 class="card-title"><i class="fas fa-chart-bar"></i> Room Analysis Results</h2>
      
      <div class="measurements-toggle">
        <span class="toggle-label">Metric</span>
        <label class="toggle-switch">
          <input type="checkbox" id="unitToggle">
          <span class="toggle-slider"></span>
        </label>
        <span class="toggle-label">Imperial</span>
        <span id="currentUnit" class="current-unit">Metric</span>
      </div>
      
      <div class="result-card">
        <div class="metric-box">
          <div class="metric-label">Width</div>
          <div class="metric-value"><span id="widthValue">0</span></div>
          <div class="metric-unit" id="widthUnit">meters</div>
        </div>
        <div class="metric-box">
          <div class="metric-label">Length</div>
          <div class="metric-value"><span id="lengthValue">0</span></div>
          <div class="metric-unit" id="lengthUnit">meters</div>
        </div>
        <div class="metric-box">
          <div class="metric-label">Height</div>
          <div class="metric-value"><span id="heightValue">0</span></div>
          <div class="metric-unit" id="heightUnit">meters</div>
        </div>
        <div class="metric-box">
          <div class="metric-label">Area</div>
          <div class="metric-value"><span id="areaValue">0</span></div>
          <div class="metric-unit" id="areaUnit">m¬≤</div>
        </div>
      </div>

      <div class="canvas-container">
        <canvas id="roomCanvas"></canvas>
      </div>

      <h3 style="margin-top: 20px;"><i class="fas fa-lightbulb"></i> Wall Details</h3>
      <div id="wallsTableContainer">
        <table class="walls-table">
          <thead>
            <tr>
              <th>Wall</th>
              <th>Length</th>
              <th>Height</th>
            </tr>
          </thead>
          <tbody id="wallsTableBody">
          </tbody>
        </table>
      </div>

      <h3 style="margin-top: 20px;"><div class="feature-icon"><i class="fas fa-eye"></i></div> Room Objects</h3>
      <div id="objectsList" class="objects-list">
      </div>

    </div>

    <footer>
      <p>RoomPlan Data Extractor &copy; 2025 | For use with Apple RoomPlan JSON files</p>
    </footer>
  </div>

  <script>
    // DOM Elements
    const resultSection = document.getElementById('resultSection');
    const alertContainer = document.getElementById('alertContainer');
    const unitToggle = document.getElementById('unitToggle');
    const currentUnit = document.getElementById('currentUnit');
    
    // Metric values
    const widthValue = document.getElementById('widthValue');
    const lengthValue = document.getElementById('lengthValue');
    const heightValue = document.getElementById('heightValue');
    const areaValue = document.getElementById('areaValue');
    
    // Units
    const widthUnit = document.getElementById('widthUnit');
    const lengthUnit = document.getElementById('lengthUnit');
    const heightUnit = document.getElementById('heightUnit');
    const areaUnit = document.getElementById('areaUnit');
    
    // Table elements
    const wallsTableBody = document.getElementById('wallsTableBody');
    const objectsList = document.getElementById('objectsList');
    
    // Canvas
    const roomCanvas = document.getElementById('roomCanvas');
    const ctx = roomCanvas.getContext('2d');
    
    // Global variables
    let processedData = null; // Will hold the parsed & processed room data
    let isMetric = true;
    
    // Initialize
    init();
    
    function init() {
      // Toggle metric/imperial
      unitToggle.addEventListener('change', toggleUnits);
  
      
      // Set canvas size
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);
    }
    
    function resizeCanvas() {
      const container = roomCanvas.parentElement;
      roomCanvas.width = container.offsetWidth;
      roomCanvas.height = container.offsetHeight;
      
      // Redraw if we have data
      if (processedData) {
        drawRoom(processedData);
      }
    }
    
    function extractRoomDetails(roomPlanData) {
      console.log("Extracting room details from data", roomPlanData);
      
      // Log all properties to understand the structure
      console.log("Data properties:", Object.keys(roomPlanData));
      
      // Validate structure and provide more detailed error
      if (!roomPlanData) {
        return { error: "Invalid RoomPlan data: Data is null or undefined" };
      }
      
      // Try to adapt to any possible structure the data might have
      let floors = [];
      let walls = [];
      
      // Check different possible structures of the data
      if (roomPlanData.surfaces) {
        console.log("Found surfaces property with", roomPlanData.surfaces.length, "items");
        floors = roomPlanData.surfaces.filter(s => s.category === "Floor" || s.category === "floor");
        walls = roomPlanData.surfaces.filter(s => s.category === "Wall" || s.category === "wall");
      } else if (roomPlanData.floors) {
        console.log("Found floors property with", roomPlanData.floors.length, "items");
        floors = roomPlanData.floors;
      } else {
        // Log all top-level properties for debugging
        for (const key in roomPlanData) {
          console.log(`Property ${key}:`, roomPlanData[key]);
        }
      }
      
      // If we don't have wall data in the expected place, try alternatives
      if (walls.length === 0 && roomPlanData.walls) {
        walls = roomPlanData.walls;
      }
      
      console.log(`Found ${floors.length} floors and ${walls.length} walls`);
      
      // Create some minimal data if we can't find anything
      if (floors.length === 0 && walls.length === 0) {
        console.warn("No floors or walls found - creating placeholder data");
        // Return placeholder data so at least something displays
        return {
          dimensions: { width: 3, length: 4, height: 2.5 },
          area: { metric: 12, imperial: 129.17 },
          walls: [
            { id: 1, length: 3, height: 2.5 },
            { id: 2, length: 4, height: 2.5 },
            { id: 3, length: 3, height: 2.5 },
            { id: 4, length: 4, height: 2.5 }
          ],
          objects: [],
          raw: roomPlanData
        };
      }
      
      try {
        // Extract dimensions from the first floor
        const floor = floors[0];
        if (!floor || !floor.dimensions) {
          return { error: "No floor dimensions found" };
        }
        
        console.log("Floor data:", floor);
        
        // Access dimensions based on actual structure
        // Assuming dimensions property exists and contains [width, length]
        const width = floor.dimensions ? floor.dimensions[0] : 0; // in meters
        const length = floor.dimensions ? floor.dimensions[1] : 0; // in meters
        const floorAreaMeters = width * length;
        
        // Convert area to square feet
        const floorAreaFeet = floorAreaMeters * 10.7639;
        
        // Extract wall data
        const processedWalls = walls.map((wall, index) => {
          return {
            id: index + 1,
            length: wall.dimensions ? parseFloat(wall.dimensions[0].toFixed(2)) : null,
            height: wall.dimensions ? parseFloat(wall.dimensions[1].toFixed(2)) : null,
            position: wall.transform ? (Array.isArray(wall.transform) ? wall.transform.slice(12, 15) : null) : null
          };
        });
        
        // Average wall height
        const wallHeights = processedWalls
          .map(w => w.height)
          .filter(h => h !== null);
        const averageHeight = wallHeights.length
          ? parseFloat((wallHeights.reduce((a, b) => a + b, 0) / wallHeights.length).toFixed(2))
          : null;
        
        // Objects (doors, windows, furniture)
        const objects = [];
        
        // Process openings (doors & windows)
        if (roomPlanData.openings) {
          roomPlanData.openings.forEach((opening, idx) => {
            const type = opening.category === "Door" ? "Door" : 
                        opening.category === "Window" ? "Window" : "Opening";
            objects.push({
              type: type,
              id: `${type.toLowerCase()}_${idx + 1}`,
              dimensions: opening.dimensions,
              position: opening.transform ? (Array.isArray(opening.transform) ? opening.transform.slice(12, 15) : null) : null
            });
          });
        }
        
        // Process furniture/objects
        if (roomPlanData.objects) {
          roomPlanData.objects.forEach((obj, idx) => {
            objects.push({
              type: obj.category || 'Object',
              id: `object_${idx + 1}`,
              dimensions: obj.dimensions,
              position: obj.transform ? (Array.isArray(obj.transform) ? obj.transform.slice(12, 15) : null) : null
            });
          });
        }
        
        return {
          dimensions: {
            width: parseFloat((width || 0).toFixed(2)),
            length: parseFloat((length || 0).toFixed(2)),
            height: averageHeight || "Not available"
          },
          area: {
            metric: parseFloat(floorAreaMeters.toFixed(2)),
            imperial: parseFloat(floorAreaFeet.toFixed(2))
          },
          walls: processedWalls,
          objects,
          raw: roomPlanData
        };
      } catch (error) {
        return { error: "Error processing RoomPlan data: " + error.message };
      }
    }
    
    function displayResults(data) {
      processedData = data; // Save globally for toggling units & exports
      
      // Display dimensions
      widthValue.textContent  = isMetric ? data.dimensions.width : convertToFeet(data.dimensions.width);
      lengthValue.textContent = isMetric ? data.dimensions.length : convertToFeet(data.dimensions.length);
      
      if (data.dimensions.height === "Not available") {
        heightValue.textContent = "N/A";
      } else {
        heightValue.textContent = isMetric ? data.dimensions.height : convertToFeet(data.dimensions.height);
      }
      
      // Display area
      areaValue.textContent = isMetric ? data.area.metric : data.area.imperial;
      
      // Update units
      updateUnitLabels();
      
      // Walls table
      wallsTableBody.innerHTML = '';
      data.walls.forEach(wall => {
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>Wall ${wall.id}</td>
          <td>${isMetric ? wall.length : convertToFeet(wall.length)} ${isMetric ? 'm' : 'ft'}</td>
          <td>${wall.height ? (isMetric ? wall.height : convertToFeet(wall.height)) + (isMetric ? ' m' : ' ft') : 'N/A'}</td>
        `;
        wallsTableBody.appendChild(row);
      });
      
      // Objects
      objectsList.innerHTML = '';
      if (data.objects.length === 0) {
        objectsList.innerHTML = '<p>No objects detected in the room.</p>';
      } else {
        data.objects.forEach(obj => {
          const dims = obj.dimensions
            ? `${isMetric ? obj.dimensions[0].toFixed(2) : convertToFeet(obj.dimensions[0]).toFixed(2)} √ó 
               ${isMetric ? obj.dimensions[1].toFixed(2) : convertToFeet(obj.dimensions[1]).toFixed(2)} ${isMetric ? 'm' : 'ft'}`
            : 'N/A';
          
          const item = document.createElement('div');
          item.className = 'object-item';
          item.innerHTML = `
            <div class="object-name">
              <span class="object-icon"><i class="fas fa-${getObjectIcon(obj.type)}"></i></span>
              ${obj.type} ${obj.id.split('_')[1]}
            </div>
            <div>${dims}</div>
          `;
          objectsList.appendChild(item);
        });
      }
      
      // Draw 2D layout
      drawRoom(data);
      
      // Show the results card
      resultSection.style.display = 'block';
    }
    
    function getObjectIcon(type) {
      const icons = {
        'Door': 'door-open',
        'Window': 'window-maximize',
        'Furniture': 'couch',
        'Table': 'table',
        'Chair': 'chair',
        'Bed': 'bed',
        'Sofa': 'couch',
        'Storage': 'cabinet-filing',
        'Object': 'cube'
      };
      return icons[type] || 'cube';
    }
    
    function drawRoom(data) {
      // Clear canvas
      ctx.clearRect(0, 0, roomCanvas.width, roomCanvas.height);
      
      // Set scale and padding
      const padding = 40;
      const maxWidth = roomCanvas.width - (padding * 2);
      const maxHeight = roomCanvas.height - (padding * 2);
      
      // Scale to fit the entire floor plan
      const widthScale  = maxWidth  / data.dimensions.width;
      const heightScale = maxHeight / data.dimensions.length;
      const scale = Math.min(widthScale, heightScale);
      
      // Draw floor
      ctx.fillStyle = '#f0f0f0';
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.rect(padding, padding, data.dimensions.width * scale, data.dimensions.length * scale);
      ctx.fill();
      ctx.stroke();
      
      // Draw objects
      data.objects.forEach(obj => {
        if (obj.position && obj.dimensions) {
          const relX = obj.position[0] + (data.dimensions.width / 2);
          const relY = obj.position[2] + (data.dimensions.length / 2);
          
          // Color by type
          if (obj.type === 'Door') {
            ctx.fillStyle = '#8bc34a';
          } else if (obj.type === 'Window') {
            ctx.fillStyle = '#03a9f4';
          } else {
            ctx.fillStyle = '#9c27b0';
          }
          
          // Draw the object rectangle
          ctx.beginPath();
          ctx.rect(
            padding + (relX * scale) - ((obj.dimensions[0] / 2) * scale),
            padding + (relY * scale) - ((obj.dimensions[1] / 2) * scale),
            obj.dimensions[0] * scale,
            obj.dimensions[1] * scale
          );
          ctx.fill();
          ctx.stroke();
          
          // Label
          ctx.fillStyle = '#333';
          ctx.font = '10px Arial';
          ctx.fillText(
            obj.type,
            padding + (relX * scale) - ((obj.dimensions[0] / 2) * scale),
            padding + (relY * scale) - ((obj.dimensions[1] / 2) * scale) - 5
          );
        }
      });
      
      // Dimensions text
      ctx.fillStyle = '#333';
      ctx.font = '12px Arial';
      
      // Width dimension text
      ctx.fillText(
        `${isMetric ? data.dimensions.width.toFixed(2) + ' m' : convertToFeet(data.dimensions.width).toFixed(2) + ' ft'}`,
        padding + (data.dimensions.width * scale / 2) - 20,
        padding - 10
      );
      
      // Length dimension text
      ctx.save();
      ctx.translate(
        padding - 10,
        padding + (data.dimensions.length * scale / 2) + 20
      );
      ctx.rotate(-Math.PI / 2);
      ctx.fillText(
        `${isMetric ? data.dimensions.length.toFixed(2) + ' m' : convertToFeet(data.dimensions.length).toFixed(2) + ' ft'}`,
        0, 0
      );
      ctx.restore();
      
      // Compass
      drawCompass(roomCanvas.width - 60, 60, 20);
    }
    
    function drawCompass(x, y, radius) {
      // Outer circle
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.fillStyle = 'white';
      ctx.fill();
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 1;
      ctx.stroke();
      
      // N arrow
      ctx.beginPath();
      ctx.moveTo(x, y - radius + 5);
      ctx.lineTo(x, y - 5);
      ctx.strokeStyle = 'red';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // N label
      ctx.fillStyle = '#333';
      ctx.font = '10px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('N', x, y - radius - 5);
    }
    
    function toggleUnits() {
      isMetric = !unitToggle.checked;
      currentUnit.textContent = isMetric ? 'Metric' : 'Imperial';
      
      if (processedData) {
        displayResults(processedData);
      }
    }
    
    function updateUnitLabels() {
      widthUnit.textContent  = isMetric ? 'meters' : 'feet';
      lengthUnit.textContent = isMetric ? 'meters' : 'feet';
      heightUnit.textContent = isMetric ? 'meters' : 'feet';
      areaUnit.textContent   = isMetric ? 'm¬≤'     : 'sq ft';
    }
    
    function convertToFeet(meters) {
      return parseFloat((meters * 3.28084).toFixed(2));
    }
    
    function showAlert(message, type) {
      alertContainer.innerHTML = '';
      const alert = document.createElement('div');
      alert.className = `alert alert-${type}`;
      
      if (type === 'error') {
        alert.innerHTML = `<i class="fas fa-exclamation-circle"></i> ${message}`;
      } else {
        alert.innerHTML = `<i class="fas fa-check-circle"></i> ${message}`;
      }
      
      alertContainer.appendChild(alert);
      
      // Auto-clear success alerts after 5s
      if (type === 'success') {
        setTimeout(() => {
          if (alertContainer.contains(alert)) {
            alertContainer.removeChild(alert);
          }
        }, 5000);
      }
    }
    
    function clearAlert() {
      alertContainer.innerHTML = '';
    }
    

    
    function exportJSON() {
      if (!processedData) {
        showAlert('No data to export.', 'error');
        return;
      }
      
      // Create a processed version of the data
      const exportData = {
        dimensions: processedData.dimensions,
        area: processedData.area,
        walls: processedData.walls,
        objects: processedData.objects,
        exportDate: new Date().toISOString(),
        units: isMetric ? 'metric' : 'imperial'
      };
      
      // Create a download link
      const dataStr = JSON.stringify(exportData, null, 2);
      const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
      
      const exportFileName = 'roomplan_processed_' + new Date().getTime() + '.json';
      const linkElement = document.createElement('a');
      linkElement.setAttribute('href', dataUri);
      linkElement.setAttribute('download', exportFileName);
      linkElement.click();
    }
    // Called from Swift (via evaluateJavaScript) to pass the JSON
    function displayData(jsonString) {
      try {
        console.log("displayData called with JSON length: " + jsonString.length);
        console.log("JSON sample (first 100 chars): " + jsonString.substring(0, 100));
        
        // Store the original string in case of error
        window.lastJsonString = jsonString.substring(0, 500);
        
        try {
          // Parse the JSON string into an object
          const roomPlanData = JSON.parse(jsonString);
          console.log("JSON parsed successfully, keys:", Object.keys(roomPlanData));
          
          // Store the raw data for debugging
          window.lastRoomPlanData = roomPlanData;
          
          // Process the data
          const result = extractRoomDetails(roomPlanData);
          console.log("Processing result:", result);
          
          if (result.error) {
            console.error("Error during extraction:", result.error);
            showAlert(result.error, 'error');
          } else {
            displayResults(result);
            showAlert('Room data processed successfully!', 'success');
          }
        } catch (e) {
          // Store the error for debugging from Swift
          window.lastDisplayDataError = e.toString();
          console.error("Error parsing JSON:", e);
          showAlert('Error parsing JSON: ' + e.message, 'error');
          throw e; // Re-throw to show in Swift error handler
        }
      } catch (outerError) {
        console.error("Outer error in displayData:", outerError);
        showAlert('Error in displayData: ' + outerError.message, 'error');
        window.lastDisplayDataError = outerError.toString();
      }
    }
    
    // Dummy function to test if JS is working
    function testFunction() {
      console.log("Test function called");
      return "JS is working!";
    }
  </script>
</body>
</html>
